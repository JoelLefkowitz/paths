#include "../../src/convert.hpp"
#include "../../src/segments.hpp"
#include <gtest/gtest.h>
#include <string>
#include <vector>

TEST(segments, resolve) {
    GTEST_SKIP();

    struct TestCase {
        std::vector<std::string> paths;
        std::string              expected;
    };

    std::vector<TestCase> cases = {
        {{""},               "."       },
        {{"."},              "."       },
        {{".."},             ".."      },
        {{"a"},              "a"       },
        {{"", ""},           "."       },
        {{"", "."},          "."       },
        {{"", ".."},         ".."      },
        {{"", "a"},          "a"       },
        {{".", ""},          "."       },
        {{".", "."},         "."       },
        {{".", ".."},        ".."      },
        {{".", "a"},         "a"       },
        {{"..", ""},         ".."      },
        {{"..", "."},        ".."      },
        {{"..", ".."},       "../.."   },
        {{"..", "a"},        "../a"    },
        {{"a", ""},          "a"       },
        {{"a", "."},         "a"       },
        {{"a", ".."},        "."       },
        {{"a", "b"},         "a/b"     },
        {{"", "", ""},       "."       },
        {{"", "", "."},      "."       },
        {{"", "", ".."},     ".."      },
        {{"", "", "a"},      "a"       },
        {{"", ".", ""},      "."       },
        {{"", ".", "."},     "."       },
        {{"", ".", ".."},    ".."      },
        {{"", ".", "a"},     "a"       },
        {{"", "..", ""},     ".."      },
        {{"", "..", "."},    ".."      },
        {{"", "..", ".."},   "../.."   },
        {{"", "..", "a"},    "../a"    },
        {{"", "a", ""},      "a"       },
        {{"", "a", "."},     "a"       },
        {{"", "a", ".."},    "."       },
        {{"", "a", "b"},     "a/b"     },
        {{".", "", ""},      "."       },
        {{".", "", "."},     "."       },
        {{".", "", ".."},    ".."      },
        {{".", "", "a"},     "a"       },
        {{".", ".", ""},     "."       },
        {{".", ".", "."},    "."       },
        {{".", ".", ".."},   ".."      },
        {{".", ".", "a"},    "a"       },
        {{".", "..", ""},    ".."      },
        {{".", "..", "."},   ".."      },
        {{".", "..", ".."},  "../.."   },
        {{".", "..", "a"},   "../a"    },
        {{".", "a", ""},     "a"       },
        {{".", "a", "."},    "a"       },
        {{".", "a", ".."},   "."       },
        {{".", "a", "b"},    "a/b"     },
        {{"..", "", ""},     ".."      },
        {{"..", "", "."},    ".."      },
        {{"..", "", ".."},   "../.."   },
        {{"..", "", "a"},    "../a"    },
        {{"..", ".", ""},    ".."      },
        {{"..", ".", "."},   ".."      },
        {{"..", ".", ".."},  "../.."   },
        {{"..", ".", "a"},   "../a"    },
        {{"..", "..", ""},   "../.."   },
        {{"..", "..", "."},  "../.."   },
        {{"..", "..", ".."}, "../../.."},
        {{"..", "..", "a"},  "../../a" },
        {{"..", "a", ""},    "../a"    },
        {{"..", "a", "."},   "../a"    },
        {{"..", "a", ".."},  ".."      },
        {{"..", "a", "b"},   "../a/b"  },
        {{"a", "", ""},      "a"       },
        {{"a", "", "."},     "a"       },
        {{"a", "", ".."},    "."       },
        {{"a", "", "b"},     "a/b"     },
        {{"a", ".", ""},     "a"       },
        {{"a", ".", "."},    "a"       },
        {{"a", ".", ".."},   "."       },
        {{"a", ".", "b"},    "a/b"     },
        {{"a", "..", ""},    "."       },
        {{"a", "..", "."},   "."       },
        {{"a", "..", ".."},  ".."      },
        {{"a", "..", "b"},   "b"       },
        {{"a", "b", ""},     "a/b"     },
        {{"a", "b", "."},    "a/b"     },
        {{"a", "b", ".."},   "a"       },
        {{"a", "b", "c"},    "a/b/c"   },
        {{"/", "a", "b"},    "/a/b"    },
        {{"a", "/", "b"},    "/b"      },
        {{"C:/", "a", "b"},  "C:/a/b"  },
        {{"a", "b.ext"},     "a/b.ext" },
    };

    for (auto test : cases) {
        test.expected = paths::platform_path(test.expected);
        EXPECT_EQ(paths::resolve(test.paths), test.expected);
    }
}
