#include "../../src/components.hpp"
#include "../../src/convert.hpp"
#include <gtest/gtest.h>
#include <string>
#include <vector>

TEST(components, tail) {
    GTEST_SKIP();

    struct TestCase {
        std::string path;
        std::string expected;
    };

    std::vector<TestCase> cases = {
        {".",         ""     },
        {"..",        ""     },
        {"a",         ""     },
        {"/",         "/"    },
        {"/.",        "/"    },
        {"/..",       "/"    },
        {"/a",        "/"    },
        {"./",        "."    },
        {"./.",       "."    },
        {"./..",      "."    },
        {"./a",       "."    },
        {"../",       ".."   },
        {"../.",      ".."   },
        {"../..",     ".."   },
        {"../a",      ".."   },
        {"a/",        "a"    },
        {"a/.",       "a"    },
        {"a/..",      "a"    },
        {"a/b",       "a"    },
        {"//",        "//"   },
        {"//.",       "//"   },
        {"//..",      "//"   },
        {"//a",       "//"   },
        {"/./",       "/."   },
        {"/./.",      "/."   },
        {"/./..",     "/."   },
        {"/./a",      "/."   },
        {"/../",      "/.."  },
        {"/../.",     "/.."  },
        {"/../..",    "/.."  },
        {"/../a",     "/.."  },
        {"/a/",       "/a"   },
        {"/a/.",      "/a"   },
        {"/a/..",     "/a"   },
        {"/a/b",      "/a"   },
        {".//",       "."    },
        {".//.",      "."    },
        {".//..",     "."    },
        {".//a",      "."    },
        {"././",      "./."  },
        {"././.",     "./."  },
        {"././..",    "./."  },
        {"././a",     "./."  },
        {"./../",     "./.." },
        {"./../.",    "./.." },
        {"./../..",   "./.." },
        {"./../a",    "./.." },
        {"./a/",      "./a"  },
        {"./a/.",     "./a"  },
        {"./a/..",    "./a"  },
        {"./a/b",     "./a"  },
        {"..//",      ".."   },
        {"..//.",     ".."   },
        {"..//..",    ".."   },
        {"..//a",     ".."   },
        {".././",     "../." },
        {".././.",    "../." },
        {".././..",   "../." },
        {".././a",    "../." },
        {"../../",    "../.."},
        {"../../.",   "../.."},
        {"../../..",  "../.."},
        {"../../a",   "../.."},
        {"../a/",     "../a" },
        {"../a/.",    "../a" },
        {"../a/..",   "../a" },
        {"../a/b",    "../a" },
        {"a//",       "a"    },
        {"a//.",      "a"    },
        {"a//..",     "a"    },
        {"a//b",      "a"    },
        {"a/./",      "a/."  },
        {"a/./.",     "a/."  },
        {"a/./..",    "a/."  },
        {"a/./b",     "a/."  },
        {"a/../",     "a/.." },
        {"a/../.",    "a/.." },
        {"a/../..",   "a/.." },
        {"a/../b",    "a/.." },
        {"a/b/",      "a/b"  },
        {"a/b/.",     "a/b"  },
        {"a/b/..",    "a/b"  },
        {"a/b/c",     "a/b"  },
        {"C:/a/b/c",  "C:a/b"},
        {"a/b/c.ext", "a/b"  },
    };

    for (auto test : cases) {
        test.path     = paths::platform_path(test.path);
        test.expected = paths::platform_path(test.expected);
        EXPECT_EQ(paths::tail(test.path), test.expected);
    }
}
